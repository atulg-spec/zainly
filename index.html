<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Body Measurement Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 20px;
        }

        video,
        canvas {
            display: block;
            margin: 0 auto;
            border: 1px solid #ccc;
        }

        #results {
            margin-top: 20px;
        }

        #guidance {
            margin-top: 20px;
        }
    </style>
</head>

<body>
    <h1>AI Body Measurement Tool</h1>
    <video id="video" width="640" height="480" autoplay></video>
    <canvas id="canvas" width="640" height="480"></canvas>
    <div>
        <label for="tshirtType">Select T-shirt Type:</label>
        <select id="tshirtType">
            <option value="regular">Regular</option>
            <option value="oversize">Oversize</option>
        </select>
    </div>
    <button id="capture">Capture</button>
    <div id="results"></div>
    <div id="guidance">
        <p>Please stand approximately 6 feet away from the camera.</p>
        <p>Make sure you are in a well-lit environment for accurate measurements.</p>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet"></script>
    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const resultsDiv = document.getElementById('results');
        const tshirtTypeSelect = document.getElementById('tshirtType');
        let net;

        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        resolve(video);
                    };
                });
            } catch (error) {
                console.error('Error accessing camera:', error);
                alert('Error accessing camera: ' + error.message);
            }
        }

        async function loadModel() {
            try {
                net = await posenet.load();
            } catch (error) {
                console.error('Error loading model:', error);
                alert('Error loading model: ' + error.message);
            }
        }

        async function estimatePose() {
            try {
                const pose = await net.estimateSinglePose(video, {
                    flipHorizontal: false
                });
                drawPose(pose);
                const measurements = calculateMeasurements(pose);
                recommendSize(measurements);
            } catch (error) {
                console.error('Error estimating pose:', error);
                resultsDiv.innerHTML = `<p>Error estimating pose: ${error.message}</p>`;
            }
        }

        function drawPose(pose) {
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            pose.keypoints.forEach(keypoint => {
                if (keypoint.score > 0.5) {
                    ctx.beginPath();
                    ctx.arc(keypoint.position.x, keypoint.position.y, 5, 0, 2 * Math.PI);
                    ctx.fillStyle = 'red';
                    ctx.fill();
                }
            });
        }

        function calculateMeasurements(pose) {
            const leftShoulder = pose.keypoints.find(point => point.part === 'leftShoulder').position;
            const rightShoulder = pose.keypoints.find(point => point.part === 'rightShoulder').position;
            const leftHip = pose.keypoints.find(point => point.part === 'leftHip').position;
            const rightHip = pose.keypoints.find(point => point.part === 'rightHip').position;

            const shoulderWidth = Math.sqrt(Math.pow(rightShoulder.x - leftShoulder.x, 2) + Math.pow(rightShoulder.y - leftShoulder.y, 2));
            const hipWidth = Math.sqrt(Math.pow(rightHip.x - leftHip.x, 2) + Math.pow(rightHip.y - leftHip.y, 2));

            return { shoulderWidth, hipWidth };
        }

        function recommendSize({ shoulderWidth, hipWidth }) {
            const tshirtType = tshirtTypeSelect.value;
            const sizeChart = {
                regular: {
                    S: { shoulder: 380, hip: 380 },
                    M: { shoulder: 400, hip: 400 },
                    L: { shoulder: 420, hip: 420 },
                    XL: { shoulder: 440, hip: 440 },
                    XXL: { shoulder: 460, hip: 460 },
                },
                oversize: {
                    S: { shoulder: 400, hip: 400 },
                    M: { shoulder: 420, hip: 420 },
                    L: { shoulder: 440, hip: 440 },
                    XL: { shoulder: 460, hip: 460 },
                    XXL: { shoulder: 480, hip: 480 },
                }
            };

            let recommendedSize = 'Unknown';

            for (const [size, measurements] of Object.entries(sizeChart[tshirtType])) {
                if (shoulderWidth <= measurements.shoulder && hipWidth <= measurements.hip) {
                    recommendedSize = size;
                    break;
                }
            }

            resultsDiv.innerHTML = `
        <p>Shoulder Width: ${shoulderWidth.toFixed(2)} px</p>
        <p>Hip Width: ${hipWidth.toFixed(2)} px</p>
        <p>Recommended T-shirt Size: ${recommendedSize}</p>
    `;
        }

        document.getElementById('capture').addEventListener('click', estimatePose);

        async function setup() {
            await setupCamera();
            await loadModel();
        }

        setup(); // Call setup function to start the camera and model loading process

    </script>
</body>

</html>